# interpreter/simulator.py

def load_program(machine_codes):
    """
    Load the machine codes into memory.
    For simplicity, store the codes in a list.
    """
    return machine_codes

def execute_program(memory):
    """
    Execute the machine code stored in memory.
    This is a simple simulation that demonstrates fetching, decoding, and executing.
    """
    pc = 0
    registers = [0] * 16  # 16 registers (r0 to r15)
    while pc < len(memory) * 4:
        # Calculate instruction index
        instr_index = pc // 4
        instruction = memory[instr_index]
        opcode = instruction >> 27
        # Halt check (opcode 0b11111 is HLT)
        if opcode == int('11111', 2):
            print("HLT encountered. Stopping execution.")
            break

        # For demonstration, print the instruction and simulate execution.
        # You need to decode operands based on the instruction format.
        print(f"PC: {pc:04} Instruction: {instruction:032b}")
        
        # Update pc to next instruction. (In a real simulator, modify pc based on branch instructions.)
        pc += 4

if __name__ == '__main__':
    # For testing, assume machine codes are passed as a list
    # This can be replaced by reading a machine code file generated by the assembler.
    sample_program = [
        0b00000000000000000000000000000000,  # Dummy instruction example
        0b11111000000000000000000000000000   # HLT instruction
    ]
    memory = load_program(sample_program)
    execute_program(memory)
